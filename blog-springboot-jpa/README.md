## 개인 블로그 백엔드 프로젝트

**프로젝트 개요**

여러 블로그 플랫폼(티스토리, 네이버 블로그, 워드프레스, 벨로그 등)을 사용하면서 느꼈던 불편했던점을 개선하고, 저만의 기능과 디자인을 구현하기 위해 개발한 클라우드 기반 개인 블로그 백엔드 시스템입니다. 사용자별 블로그, 게시물 관리, 검색 기능, 카테고리 시스템, 사용자 프로필 업데이트, 이미지/파일 업로드(다중 이미지 포함), 성능, 보안 및 권한 관리 등 블로그 플랫폼에 필요한 핵심 기능들을 Spring Boot 기반으로 구현했습니다.

**기술 스택**

*   **백엔드 기본**
    *   언어: Java 17
    *   프레임워크: Spring Boot
    *   빌드 도구: Gradle
*   **데이터 관리**
    *   ORM: JPA/Hibernate
    *   데이터베이스: MySQL(AWS RDS)
    *   쿼리 최적화: QueryDSL, JPQL
    *   캐싱: Redis
*   **보안**
    *   인증/인가: Spring Security, JWT
    *   OAuth2: Google 로그인 연동
    *   AOP: Spring AOP(요청 제한, 로깅, 성능 측정)
*   **인프라**
    *   클라우드: AWS EC2, RDS, S3
    *   컨테이너화: Docker
    *   웹 서버/프록시: NGINX
    *   CI/CD: GitHub Actions
*   **기타 도구**
    *   모니터링: Prometheus, Grafana, Spring Actuator
    *   로깅: log4j2
    *   문서화: Swagger UI
    *   배치 처리: Spring Batch
    *   테스트: JUnit5, Mockito, TestContainers, REST Assured

**주요 기능**

*   **사용자 인증/인가 시스템**
    *   Form 회원가입
        *   이메일 기반 회원가입과 인증 코드 검증 프로세스
        *   블로그ID, 사용자명, 이메일 중복 확인 AOP 기반 요청 제한
        *   인증코드 검증, 재발급 AOP 기반 요청 제한
        *   회원가입 요청 AOP 기반 요청 제한
        *   요청 제한은 1분에 최대 3회 제한
        *   제한에 걸릴 시 1분 뒤에 초기화 및 재요청 가능
        *   @Valid를 활용한 회원가입 데이터에 대한 입력값 검증
            * 프론트측에서 유효성 검사를 진행하지만 요청을 우회할 수 있기 때문에 최종 보안 검증은 백엔드에서 검증
        * 회원가입 성공 시 JWT 토큰 발급 및 사용자가 가장 최근에 있었던 페이지 유지     
    *   로그인 시스템
        *   Form 로그인: 이메일/비밀번호 기반
            * Form 로그인의 경우 백엔드 쪽에서 리다이렉트 처리를 안해주었기 때문에 바로 응답 헤더에 AccessToken을 담아서 전송   
        *   OAuth2 로그인: Google 소셜 인증
            * 신규/기존 사용자 구분 처리
            * 신규 사용자는 추가 정보(블로그ID, 사용자명) 입력 프로세스 제공
            * 기존 사용자 리다이렉트 시 토큰 처리 프로세스:
              * 리다이렉트시 헤더에 담긴 토큰을 받을 수 없음. 따라서 아래와 같이 진행
              * 임시 액세스 토큰을 쿠키에 포함하여 응답 (리다이렉트시 헤더 접근 제한 우회)
              * 프론트엔드에서 백엔드로 재요청
              * 쿠키 내 액세스 토큰 검증 후 응답 헤더로 최종 토큰 전달
        * 로그인 성공 시 JWT 토큰 발급 및 사용자가 가장 최근에 있었던 페이지 유지  
    *   로그아웃 처리
        *   프론트엔드에서 사용자 명시적 로그아웃 요청 시 처리
        *   쿠키 저장 토큰 삭제 (Refresh Token, OAuth2 Access Token)
        *   액세스 토큰은 프론트측에서 삭제 처리
        *   Redis에 저장된 리프레시 토큰 삭제
        *   만료된 토큰도 변조되지 않았다면 정상 로그아웃 처리 
    *   JWT 토큰 관리
        *   Access Token: 
            *  1시간 유효, 프론트측 로컬스토리지 저장(CSRF 공격 방지)
            * XSS 취약점 위험 짧은 만료 시간 (1시간)으로 대응. 사용자 경험과 보안을 고려해서 시간 변경 가능성 있음
        *   Refresh Token: 
            *   프론트측 쿠키 보관 - 액세스토큰 재발급용 HttpOnly 쿠키(클라이언트측 Javascript 접근 차단)
            *   백엔드측 - Redis 저장으로 프론트측 쿠키 시간과 대응하여 자동 만료, 사용자가 명시적인 로그아웃 시 만료
            *   "Remember Me" 기능 
                *   리프레시 토큰 만료 기간 연장(2주), 비체크시 하루 유효
                *   OAuth2 로그인과 Form 로그인 모두 지원 
        *   Refresh Token을 통한 Access Token 자동 갱신 프로세스(사용자 로그인 유지로 인한 사용자 경험 향상)
    *   권한 검증 시스템
        *   TokenAuthenticationFilter를 통한 인증 정보 처리
        *   @PreAuthorize 블로그 소유자 권한 검증
        * 공개/비공개 게시물 접근 제어:
          * 토큰 필터에서 블로그 주인 여부 확인 및 블로그 주인인 경우에만 SecurityContextHolder에 인증 정보 저장
          * 블로그 주인은 postId로만 조회하여 모든 글(공개/비공개) 접근 가능
          * 타 사용자는 postId + PUBLIC 상태 조건으로 조회하여 공개글만 접근 가능  
*   **게시물 관리 시스템**
    *   게시물 CRUD
        *   게시물 생성: 제목, 내용, 카테고리, 태그, 파일 및 이미지, 대표 이미지, 공개여부 설정
            * 게시글 작성 시 React Quill 위지윅 에디터 사용   
        *   게시물 조회:
            *   사용자가 React Quill를 사용해 입력한 HTML 콘텐츠를 DB에서 그대로 불러와 화면에 표시하도록 구현   
            *   인덱스 페이지(모든 공개글)
            *   사용자별 페이지(블로그 주인은 비공개글 포함)
            *   카테고리별 조회
            *   상세 페이지
        *   게시물 수정/삭제: 권한 확인 및 연관 데이터 처리
    *   페이지네이션 및 검색
        *   제목, 내용, 제목/내용 기반 검색
        *   RESTful API 설계 원칙 적용
            *   페이지네이션은 쿼리 파라미터 대신 PathVariable 형식 채택 (더 RESTful한 URL 구조 지향)
            *   검색은 일관성을 위해 쿼리 파라미터 방식 적용
*   **카테고리 시스템**
    *   2단계 카테고리 구조(부모/자식)
    *   orderIndex 필드를 통한 순서 관리
    *   일괄 업데이트 API 제공
*   **태그 시스템**
    *   다대다 관계 구현(Post-Tag-PostTag)
    *   다른 사용자 또는 다른 게시글에서 미사용 태그만 DB에서 제거
*   **파일 관리 시스템**
    *   AWS S3 연동
    *   이미지/파일 저장소
    *   임시/최종 저장소 분리
        *   블로그ID/temp: 작성 중 임시 저장
        *   블로그ID/final: 게시물 확정 시 최종 저장
    *   파일 크기 제한(이미지 5MB, 파일 10MB, 게시물 전체 20MB)
    *   비동기 처리를 통한 S3 작업 최적화
    *   Spring Batch 작업
        *   사용자가 작성/수정 중 페이지 이탈 시 남은 임시 파일/이미지 정리
        *   S3 작업이 빈번하게 발생 시 비용 문제가 발생할 수 있어, 현재 비활성화. 추후 활성화시 비용 고려해 주1회 제한 예정
    *   Proxy Image API
        *   외부 이미지 CORS 문제 해결을 위한 프록시 구현
*   **사용자 프로필 관리**
    *   프로필 정보
        *   사용자명(닉네임), 블로그명, 프로필 이미지 관리
    *   Public/Private 프로필 API 분리
        *   Public: 공개 정보
        *   Private: 이메일 등 개인 정보(권한 검증 필요)

*   **성능 최적화**

    *   **JPA 최적화**
        *   초기 양방향 매핑 시 추상적인 코드로 인한 코드의 명확성 감소 및 성능이 저하될 가능성이 있음
        *   이후 성능과 생산성의 균형으로 단방향 매핑을 고려 했으나, 비즈니스 로직 최적화 및 성능 향상을 위해 연관관계 매핑 제거 결정
        *   개인적인 생각으로 성능과 생산성 중간 지점을 찾는것도 좋지만, JPA 연관관계 매핑을 제거해서 작업하는 방식에 익숙해지면 성능 향상과 생산성 두마리의 토끼를 잡을 수 있지 않을까 생각
        *   연관관계 매핑 제거를 통한 비즈니스 로직 최적화 및 N+1 문제 원천 차단
        *   QueryDSL DTO Projection을 활용한 필요 필드만 조회
        *   일괄 처리를 통한 DB 작업 최소화
    *   **캐싱 전략**
        *   Redis 활용 조건:
            * 보안상 문제 없어야 함
            * 자주 변경되지 않고 빈번하게 조회되는 데이터(DB 요청 감소)
        *   Refresh Token 관리
            *   자동 만료 시간 설정으로 별도 토큰 관리 불필요
            *   DB 요청 감소를 통한 성능 향상
            *   토큰 검증 및 재발급 프로세스 최적화     
        *   Redis 활용 사례:
            *   사용자 공개 프로필 데이터: 24시간
            *   카테고리 데이터: 24시간
            *   사용자 존재 유무: 24시간
            *   중복 확인 데이터: 6시간 - 저장공간 낭비 고려해서 6시간으로 결정
            *   Refresh Token 관리
            *   임시 데이터 (3~5분): 비즈니스 로직 처리 중 임시 데이터 저장
        *   캐시 수동 무효화 구현(데이터 변경 시)
    *   **인덱스 최적화**
        *   MySQL Workbench EXPLAIN 분석을 통한 인덱스 설계
        *   읽기/쓰기/저장 공간 작업 특성을 고려한 인덱스 구성
    *   **기술적 의사 결정**
        *   ElasticSearch 사용 후 제거 결정
            *   소규모 데이터에서 MySQL 인덱스와 성능 차이가 미미함
            *   운영 비용 및 유지보수 복잡성 고려
            *   MySQL 인덱스 최적화로 검색 기능 대체
        *   ElasticSearch 사용했을 당시
            * 한글 검색을 위해 nori analyzer 사용 
            * ngram을 사용하여 한글자 단위로 검색 허용
            * ES 동기화시 실패할 경우 최대 3회까지 재시도   

*   **예외 처리 및 로깅**
    *   **일관된 예외 처리**
        *   GlobalExceptionHandler를 통한 중앙 관리
        *   BusinessException과 SystemException 분리
        *   AOP를 활용한 자동 예외 로깅
    *   **로깅 전략**
        *   컨트롤러, 메서드 진입점 로깅
        *   분기 처리 로깅
        *   LoggingAspect를 통한 예외 자동 기록

*   **배포 및 운영 환경**

    *   **AWS 인프라**
        *   프리티어 단계에서 비용 0원 운영 목적  
        *   EC2: 애플리케이션 서버
        *   RDS: MySQL 데이터베이스
        *   S3: 파일 저장소 
        *   AWS RDS 접근 시 SSH 터널링 적용 
            * 개발 환경 MySQL Workbench에서 Public으로 접근 시 비용 발생 및 잠재적 보안 문제 고려   
    *   **Docker 컨테이너화**
        *   스프링 부트, Redis, Prometheus, Grafana 컨테이너화
        *   개발/운영 환경 설정 분리
    *   **NGINX 프록시**
        *   HTTPS 요청 처리
        *   SSL 인증서 관리
        *   EC2내 도커 컨테이너에서 실행 중인 스프링부트앱으로 요청 전달
    *   **CI/CD 파이프라인**
        *   GitHub Actions를 통한 자동화
        *   테스트, 빌드, 배포 과정 자동화
        *   비용 효율적인 무중단 배포 구현
    *   **모니터링 시스템**
        *   Prometheus: 메트릭 수집
        *   Grafana: 시각화 대시보드
        *   Spring Actuator: 애플리케이션 헬스 체크
    *   개발/운영 환경 스프링 설정 파일 분리

*   **API 문서화**
    *   Swagger Integration
    *   각 컨트롤러 메소드마다 상세 문서화
    *   @Tag, @Operation, @Parameter, @ApiResponses 활용
    *   API 테스트 환경 제공

*   **개발 협업 지원**
    *   프론트엔드/백엔드 인터페이스 명세
    *   요청/응답 스키마 정의

*   **테스트 전략**
    *   단위 테스트
        *   컨트롤러: @WebMvcTest
        *   서비스: @ExtendWith(MockitoExtension.class)
        *   리포지토리: @DataJpaTest
    *   통합/E2E 테스트
        *   통합 테스트: @SpringBootTest
        *   E2E 테스트: REST Assured
    *   외부 의존성 테스트
        *   TestContainers: Redis 연동 테스트
    *   향후 테스트 코드 작성 우선 순위 
        * 핵심 비즈니스 로직
        * 기존 코드 변경 시 해당 코드가 그 이후에 변경 가능성이 낮을 경우   

**프로젝트 구조**

```
src/
├── main/
│   ├── java/com/yhs/blog/springboot/jpa
│   │   ├── aop/        # AOP 관련 클래스(요청 제한, 로깅, 성능 측정)
│   │   ├── common/     # 공통 유틸리티 및 상수
│   │   ├── config/     # 애플리케이션 설정
│   │   ├── domain/     # 도메인 엔티티 및 해당 도메인의 서비스/레포지토리
│   │   ├── exception/  # 예외 처리 클래스
│   │   ├── security/   # 보안 관련 설정 및 UserDetailsService 구현체
│   │   ├── web/        # 웹 계층 (프론트측 쿠키에 액세스/리프레시 토큰 저장)
│   └── resources/      # 스프링 설정 파일 및 log4j2 설정 파일
│       ├── application.yml
│       ├── application-dev.yml
│       └── application-prod.yml
│       └── application-test.yml
│       └── log4j2-spring.xml
└── test/                   # 테스트 코드
```

**향후 우선 순위**

현재는 핵심 기능 위주로 구현했으며, 추가적으로 아래 기능을 구현할 예정입니다. 

1.   글 생성/수정 시 임시 저장 기능: 글 생성/수정 시 콘텐츠 보호 목적  
2.   알림 기능: 실시간 서비스와 유사한 실시간 알림 기능
3.  댓글, 대댓글 기능: 실제 서비스와 유사하게 사용자 간 소통 기능
4.   테스트 커버리지 확대: 테스트 커버리지 확대로 코드 품질 향상 및 시스템 안정성 향상
5.  좋아요 기능: 좋아요 기능으로 인기 게시물 식별
6.   관리자 페이지: 콘텐츠와 사용자 관리를 위한 관리자 페이지

**배포 서비스**

실제 구현된 블로그는 다음 링크에서 확인 가능합니다: https://dduhalog.duckdns.org/
감사합니다.

 
